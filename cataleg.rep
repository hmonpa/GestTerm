struct node_hash {
    string _k;                  // Clau = String no buit
    Valor _v;                   // Valor
};
node_hash **_taula;             // Taula de punters a node

nat _mida;                      // Mida de la taula
nat _quants;                    // Nombre d'elements guardats al diccionari

static nat const alpha = 0.75;  // Factor de càrrega
/* Com a regla general, 0.75 es un bon factor de càrrega ja que ofereix un
bon equilibri entre costos temporals i espaials, valors més alts fan
decréixer la sobrecàrrega de l'espai, però incrementa el cost de la cerca */

/* Quedaria decidir también el tipo de estrategia para la resolución de colisiones
    1. Open Hashing
        1.1. Sinonimos encadenados indirectos
        1.2. Sinonimos encadenados indirectos
    2. Open addressing
        2.1. Sondeo lineal

// Mètodes privats
void dispersio();               // PDTE: Razonar una buena estrategia buscando equilibrio
                                // entre costes asumibles y fácil (o asumible) implementación


// Raonament i decisions

/*
  La nostra primera idea després de raonar les caràcteristiques de la classe catàleg,
  va ser escollir un BST per desenvolupar el diccionari, pels següents motius:

  1. Implementació: Un BST no deixa de ser un arbre binari buit, o, un arbre binari tal que,
    per a tot node, la clau del node es més gran que qualsevol de les claus del subarbre esquerre,
    i es més petita que qualsevol de les claus del subarbre dret.
  2. Costos: Logaritmics als casos mitjos
  3. No haviem de coneixer previament la quantitat d'elements (nodes)
  4. Ens permetia tenir el parell Clau-Valor, sent la Clau un string no buit i Valor un tipus genèric

    Vam comparar els costos mitjos en comparació a altres estructures:

    +--------------------------------------------------------------------------------------------+
    |  Avg case    |       Crear        |      Inserir      |     Elimina       |    Consulta    |
    +--------------------------------------------------------------------------------------------+
    |  Hash table  |       θ(n)         |       θ(1)        |     θ(1)          |      θ(1)      |
    |  BST / AVL   |       θ(1)         |       θ(log n)    |     θ(log n)      |      θ(log n)  |
        TRIES:
    |   Punters    |       θ(1)         |       θ(L)        |     θ(L)          |      θ(L)      |
    | PrimfSeggerm |       θ(1)         |       θ(L·S)      |     θ(L·S)        |      θ(L·S)    |
    |     TST      |       θ(1)         |     θ(L·log S)    |   θ(L·log S)      |    θ(L·log S)  |
    +--------------------------------------------------------------------------------------------+
    · S = Nombre de Símbols
    · L = Longitud de la Clau

    No obstant, la nostra idea inicial va canviar, ja que es volia que la consulta a les dades,
    sigues tan ràpida com fos possible, per tant, comparant els costos temporals, encara que els
    costos espaials fossin més grans, finalment ens vam decantar per una taula de dispersió (Hash Table)


*/
